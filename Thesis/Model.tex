%TC:ignore
\begin{code}[hide]%
\>[0]\<%
\\
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{Model}\AgdaSpace{}%
\AgdaKeyword{where}%
\>[2I]\AgdaComment{--\ This\ allows\ me\ to\ use\ arbitrary\ module\ names\ from\ here\ }\<%
\\
\>[.][@{}l@{}]\<[2I]%
\>[19]\AgdaComment{--\ onwards}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Real}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaRecord{Real}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Nat.Base}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{ℕ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaRecord{NonZero}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{renaming}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}*\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}*ₙ\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}+ₙ\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Nat.Properties}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{m*n≢0}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Binary.PropositionalEquality}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{Eq}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Eq}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≡\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{cong}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{sym}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Eq.≡-Reasoning}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Algebra.Structures}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{AlgebraStructures}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{AlgebraStructures}%
\>[24]\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaRecord{IsCommutativeMonoid}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Algebra.Definitions}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{AlgebraDefinitions}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Algebra.Core}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Function.Base}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}\$\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∘\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Product.Base}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}×\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{proj₁}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{proj₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{renaming}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨\AgdaUnderscore{},\AgdaUnderscore{}⟩}}\AgdaSymbol{)}\<%
\end{code}
%TC:endignore
% From Equation \ref{eq:DFT_Definition} we have a definition of the DFT which we 
% know to be correct, but this is not yet in a useable form. 
% In order to prove against this definition we must define our DFT in Agda given 
% some definition of Complex numbers, and some definition of Vectors. 
% 
% As we did above, we must then perform a likewise conversion for our FFT 
% definition, Equation \ref{eq:FFT_Definition}.
% Although it would be possible to implement this definition with respect to
% an input Vector, using instead an input Matrix of arbitrary shape will make both
% the definition, and the proofs applicable to any radix or mix of radices.
% 
% Given that Vectors can be considered one dimenti


\section{Implementation}

Before the DFT and FFT can be reasoned on, it is important to invest into the
definition of some data structures which can accurately encode all required data
and operations upon that data.
% These data structures hold useful properties about the data within them, these 
% properties can then be utilised by my implementation.
Well defined data structures allow us to abstract useful properties on the data
held within them.
This allows for reasoning to be performed on a high level where:
\begin{itemize}
\item Variations of the Fourier Transform, 
        such as the Inverse Fourier Transform, can be 
        instantiated without a need to modify the underlying code.
\item Definition can be made highly compact.
\item The possibility for out-of-bound indexing errors can be eliminated by 
        construction.
\item The FFT can be defined for an input tensor of arbitrary shape, allowing 
        multiple kernels to be defined using just one definition.
\item The FFT can be described over a number system of arbitrary structure,
        allowing it to be instantiated for any number system with the correct
        properties
\end{itemize}


\subsection{Complex Numbers}
\label{sec:complex_numbers}

% The Agda Standard library does not provide definitions for Complex numbers, it
% is therefore necessary for us to design and decide upon an encoding.
It is well known \cite{TheDFT}
that the DFT and FFT can be implemented on an arbitrary field-\textit{like}
\footnote{This structure is only field-\textit{like} because it does not require multiplicative inverses}
structure with roots of unity.
Agda allows this this idea to be captured precisely though the creation of a
structure, \AF{Cplx}, which axiomatizes this field and its properties which the FFT
and correctness proof rely on.
This is similar to Java interfaces, defining the carrier and operations, but also
allows for the properties (such as the associativity of addition) of this field to 
be defined.

This isolation allows the definition of the DFT, FFT and proofs to be instantiated
for any implementation of \AF{Cplx}.
This generality allows the use of any modular field of 
sufficient size which holds the required properties, allowing operations such as 
fast multiplication to be performed upon these fields.
% As Agda provides a builtin wrapper around IEEE754 floats\cite{IEEE754}
% the examples shown in this paper, use a simple implementation of \AF{Cplx} built 
% from pair of floating point numbers.

With the required operations and properties in mind, a structure can
be formed to encapsulate complex.
This structure first defines the carrier set, \AF{ℂ}, and the of basic operations
any implementation of complex must contain, each defined in a similar way to \AF{\_+\_} below.

\begin{AgdaMultiCode}
%TC:ignore
\begin{code}[hide]%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{ComplexMini}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{real}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Real}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Real.Real}\AgdaSpace{}%
\AgdaBound{real}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{ℝ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{0ℝ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{1ℝ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{-1ℝ}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Algebra.Structures}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{AlgebraStructures}\<%
\\
%
\>[2]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Algebra.Definitions}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{AlgebraDefinitions}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaKeyword{private}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaKeyword{variable}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaGeneralizable{N}\AgdaSpace{}%
\AgdaGeneralizable{m}\AgdaSpace{}%
\AgdaGeneralizable{r₁}\AgdaSpace{}%
\AgdaGeneralizable{x}\AgdaSpace{}%
\AgdaGeneralizable{y}\AgdaSpace{}%
\AgdaGeneralizable{k₀}\AgdaSpace{}%
\AgdaGeneralizable{k₁}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
%
\>[4]\AgdaKeyword{postulate}%
\>[15]\AgdaComment{--\ I\ realise\ how\ horrendusly\ cursed\ postulating\ an\ instance\ is...}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaKeyword{instance}\AgdaSpace{}%
\AgdaComment{--\ but\ it\ works...}\<%
\\
\>[6][@{}l@{\AgdaIndent{0}}]%
\>[8]\AgdaPostulate{nonZero-n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{NonZero}\AgdaSpace{}%
\AgdaGeneralizable{N}\<%
\\
%
\>[8]\AgdaPostulate{nonZero-r₁}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{NonZero}\AgdaSpace{}%
\AgdaGeneralizable{r₁}\<%
\\
%
\>[8]\AgdaPostulate{nonZero-x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{NonZero}\AgdaSpace{}%
\AgdaGeneralizable{x}\<%
\\
\>[0]\<%
\end{code}
%TC:endignore
\begin{code}%
\>[0][@{}l@{\AgdaIndent{1}}]%
\>[2]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaRecord{Cplx}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set₁}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\end{code}
%TC:ignore
\begin{code}[hide]%
\>[2][@{}l@{\AgdaIndent{1}}]%
\>[4]\AgdaKeyword{infix}%
\>[11]\AgdaNumber{8}\AgdaSpace{}%
\AgdaOperator{\AgdaField{-\AgdaUnderscore{}}}\<%
\\
%
\>[4]\AgdaKeyword{infixl}\AgdaSpace{}%
\AgdaNumber{7}\AgdaSpace{}%
\AgdaOperator{\AgdaField{\AgdaUnderscore{}*\AgdaUnderscore{}}}\<%
\\
%
\>[4]\AgdaKeyword{infixl}\AgdaSpace{}%
\AgdaNumber{6}\AgdaSpace{}%
\AgdaOperator{\AgdaField{\AgdaUnderscore{}+\AgdaUnderscore{}}}\ \AgdaUnderscore{}-\AgdaUnderscore{}\<%
\end{code}
%TC:endignore
\begin{code}%
%
\>[4]\AgdaKeyword{field}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaField{ℂ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
%
\>[6]\AgdaOperator{\AgdaField{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaField{ℂ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaField{ℂ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaField{ℂ}\<%
\\
%
\>[6]\AgdaComment{--\ ...}\<%
\end{code}
%TC:ignore
\begin{code}[hide]%
%
\>[6]\AgdaOperator{\AgdaField{\AgdaUnderscore{}*\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaField{ℂ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaField{ℂ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaField{ℂ}\<%
\\
%
\>[6]\AgdaOperator{\AgdaField{\AgdaUnderscore{}-\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaField{ℂ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaField{ℂ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaField{ℂ}\<%
\\
%
\>[6]\AgdaOperator{\AgdaField{-\AgdaUnderscore{}}}%
\>[10]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaField{ℂ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaField{ℂ}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[6]\AgdaField{fromℝ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaField{ℝ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaField{ℂ}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[6]\AgdaOperator{\AgdaField{e\textasciicircum{}i\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaField{ℝ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaField{ℂ}\<%
\\
%
\>[6]\AgdaField{ℂ-conjugate}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaField{ℂ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaField{ℂ}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[6]\AgdaComment{--+ω\ :\ ∀\ (N\ :\ ℕ)\ (k\ :\ ℕ)\ →\ ℂ}\<%
\\
%
\>[6]\AgdaComment{--\ Instance\ arguments\ seem\ pretty\ good\ https://agda.readthedocs.io/en/v2.5.4/language/instance-arguments.html}\<%
\\
%
\>[6]\AgdaComment{--\ ω\ really\ goes\ here}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[4]\AgdaFunction{0ℂ}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaField{ℂ}\<%
\\
%
\>[4]\AgdaFunction{0ℂ}%
\>[8]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaField{fromℝ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{0ℝ}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaFunction{-1ℂ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaField{ℂ}\<%
\\
%
\>[4]\AgdaFunction{-1ℂ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaField{fromℝ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{-1ℝ}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaFunction{1ℂ}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaField{ℂ}\<%
\\
%
\>[4]\AgdaFunction{1ℂ}%
\>[8]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaField{fromℝ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{1ℝ}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[4]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{AlgebraStructures}%
\>[28]\AgdaSymbol{\{}\AgdaArgument{A}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaField{ℂ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≡\AgdaUnderscore{}}}\<%
\\
%
\>[4]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{AlgebraDefinitions}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{A}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaField{ℂ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≡\AgdaUnderscore{}}}\<%
\\
\>[0]\<%
\\
%
\>[4]\AgdaKeyword{field}\<%
\end{code}
%TC:endignore
Addition, multiplication and negation must be proven to form a commutative ring,
meaning that a set of properties, such as multiplication distributes over addition
must hold. \cite{CommRingTheory}
\begin{code}%
\>[4][@{}l@{\AgdaIndent{1}}]%
\>[6]\AgdaComment{--\ ...}\<%
\\
%
\>[6]\AgdaField{+-*-isCommutativeRing}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{IsCommutativeRing}\AgdaSpace{}%
\AgdaOperator{\AgdaField{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaOperator{\AgdaField{\AgdaUnderscore{}*\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaOperator{\AgdaField{-\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaFunction{0ℂ}\AgdaSpace{}%
\AgdaFunction{1ℂ}\<%
\\
%
\>[6]\AgdaComment{--\ ...}\<%
\end{code}
\paragraph{Roots of unity}\label{para:roots_of_unity} as described for Complex numbers in Equation 
\ref{eq:ComplexRootsOfUnity}, must be defined for some non-zero divisor $N$ 
and some power $K$, along with some properties on them.
To ensure that the divisor $N$ is never zero, a \AF{NonZero} proof argument is 
required on $N$, guaranteeing division by zero to be impossible.
This \AF{NonZero} property is an instance argument, allowing an instance 
resolution algorithm\cite{InstanceArgs}
to perform automatic resolution on it, simplifying further proofs.
\begin{code}%
%
\>[6]\AgdaComment{--\ ...}\<%
\\
%
\>[6]\AgdaField{-ω}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{N}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{.\{\{}\AgdaSpace{}%
\AgdaBound{nonZero-n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{NonZero}\AgdaSpace{}%
\AgdaBound{N}\AgdaSpace{}%
\AgdaSymbol{\}\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{k}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaField{ℂ}\<%
\\
%
\>[6]\AgdaField{ω-N-0}%
\>[17]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaField{-ω}\AgdaSpace{}%
\AgdaGeneralizable{N}\AgdaSpace{}%
\AgdaNumber{0}%
\>[43]\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaFunction{1ℂ}\<%
\\
%
\>[6]\AgdaField{ω-N-mN}%
\>[17]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaField{-ω}\AgdaSpace{}%
\AgdaGeneralizable{N}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{N}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{*ₙ}}\AgdaSpace{}%
\AgdaGeneralizable{m}\AgdaSymbol{)}%
\>[43]\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaFunction{1ℂ}\<%
\\
%
\>[6]\AgdaField{ω-r₁x-r₁y}%
\>[17]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaField{-ω}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{r₁}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{*ₙ}}\AgdaSpace{}%
\AgdaGeneralizable{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{r₁}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{*ₙ}}\AgdaSpace{}%
\AgdaGeneralizable{y}\AgdaSymbol{)}%
\>[43]\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaField{-ω}\AgdaSpace{}%
\AgdaGeneralizable{x}\AgdaSpace{}%
\AgdaGeneralizable{y}\<%
\\
%
\>[6]\AgdaField{ω-N-k₀+k₁}%
\>[17]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaField{-ω}\AgdaSpace{}%
\AgdaGeneralizable{N}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{k₀}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+ₙ}}\AgdaSpace{}%
\AgdaGeneralizable{k₁}\AgdaSymbol{)}%
\>[43]\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{-ω}\AgdaSpace{}%
\AgdaGeneralizable{N}\AgdaSpace{}%
\AgdaGeneralizable{k₀}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaField{*}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{-ω}\AgdaSpace{}%
\AgdaGeneralizable{N}\AgdaSpace{}%
\AgdaGeneralizable{k₁}\AgdaSymbol{)}\<%
\end{code}
\end{AgdaMultiCode}


\subsection{Tensors}
In Equations \ref{eq:DFT_Definition} and \ref{eq:FFTDefinitionFromDFT}, the DFT 
and FFT are both defined for any input vector $x$ of length $N$ and length 
$r_1\times r_2$ respectively. 
This implies that it would be possible to represent the input structure for both 
the DFT and the FFT in vector form, possibly using the Agda standard libraries functional
vector definition, \verb|Data.Vec.Functionals|.

Although this structure is ideal for the DFT, the FFTs relies on index splitting,
as described in Equation \ref{eq:IndexManipulation}, to decompose the input vector
into $r₁$ parts.
For vectors this would require low level index manipulation, for a single layer 
of splitting, this is not unreasonable, but can still complicate any definitions.
For multiple layers however, where the input is split into $n$ factors, this quickly
becomes complex as the multipliers and split position for each factor must be carried
through.
This would make an kind of reasoning on the FFT, as well as generalisation,
where the FFT is called iteratively, difficult as both would be
pulled down to require the same low level of index manipulation.

The need for this low level manipulation can be removed, by creating some
definition for shaped tensors, and allowing the FFT to 
accept these tensors as inputs.
These shaped tensors can also be considered as Multi-dimensional arrays.
As well as removing the need these low level manipulations, using this definition 
will also abstract the splitting of the input vector out of the FFT making any    % This may be better discussed in the FFT section...
definition radix independent.

\begin{AgdaAlign}
%TC:ignore
\begin{code}[hide]%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{Matrix}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Nat}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{ℕ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaRecord{NonZero}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}*\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Fin}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{F}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{Fin}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{join}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{renaming}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaInductiveConstructor{fzero}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaInductiveConstructor{fsuc}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Product.Base}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}×\AgdaUnderscore{}}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{renaming}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⟨\AgdaUnderscore{},\AgdaUnderscore{}⟩}}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Sum.Base}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{inj₁}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₂}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaKeyword{private}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaKeyword{variable}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaGeneralizable{n}\AgdaSpace{}%
\AgdaGeneralizable{m}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
%
\>[6]\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaGeneralizable{Y}\AgdaSpace{}%
\AgdaGeneralizable{Z}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\end{code}
%TC:endignore
The shape of any given tensor can be described as a full binary tree of natural 
numbers.
Each leaf, \AF{ι n}, is one such natural number, one leaf 
can be considered to add one dimension to the overall shape. 
Each parent note, \AF{s ⊗ p}, joins two subtrees.
A given shape tree encodes the split of $N$ into $m$ many multipliers.

\begin{code}%
%
\>[2]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Shape}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{ι}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Shape}\<%
\\
%
\>[4]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Shape}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Shape}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Shape}\<%
\end{code}

Defining shapes as trees in place of lists allows for more information to be 
encoded about the structure of the shape. 
This data loss can be identified by converting the below tensor shapes into their
list forms, both of which are \AF{s :: p :: r :: q :: []}.
% For the FFT, this additional information should allow for the structure of parallelism 
% to be defined by the shape of the input tensor for a parallelised implementation.

%TC:ignore
\begin{code}[hide]%
%
\>[2]\AgdaKeyword{private}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaKeyword{variable}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Shape}\<%
\\
%
\>[2]\AgdaFunction{tmp}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Shape}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Shape}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Shape}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Shape}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Shape}\<%
\\
%
\>[2]\AgdaFunction{tmp}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaBound{r}\AgdaSpace{}%
\AgdaBound{q}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaKeyword{let}\<%
\end{code}
%TC:endignore
\begin{code}%
\>[2][@{}l@{\AgdaIndent{1}}]%
\>[4]\AgdaBound{s₁}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}%
\>[12]\AgdaBound{s}%
\>[15]\AgdaOperator{\AgdaInductiveConstructor{⊗}}%
\>[18]\AgdaBound{p}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{r}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaBound{q}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaBound{s₂}\AgdaSpace{}%
\AgdaSymbol{=}%
\>[12]\AgdaBound{s}%
\>[15]\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{p}%
\>[21]\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{r}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaBound{q}\AgdaSymbol{))}\<%
\end{code}
%TC:ignore
\begin{code}[hide]%
%
\>[4]\AgdaKeyword{in}\AgdaSpace{}%
\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaNumber{4}\<%
\end{code}
%TC:endignore

Array indices can then be inductively defined as a dependant type on Shapes.
This definition takes the same form as that of shapes and defines the position 
of a non-leaf nodes as being constructed by the positions of its two children 
nodes, while leaf nodes are bound by the length of that leaf.
This binding on the length of the leaf, allows the type checker to require
evidence that a positions index is not greater than the length, removing the possibility
for runtime out of bounds errors.


\begin{code}%
%
\>[2]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Position}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Shape}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{ι}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Fin}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Position}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Position}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Position}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Position}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSymbol{)}\<%
\end{code}

\AF{Position} can then be used to define the tensor data encoding, such that
tensors form indexed types
accepting a position and returning the value at that position.

\begin{code}%
%
\>[2]\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Shape}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
%
\>[2]\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{Position}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{X}\<%
\end{code}
This means any given tensor of \AF{Shape} \AF{s} and type \AF{X} accepts a
\AF{Position} of shape \AF{s} and returns a value of type \AF{X}.
This is a similar definition to that used in \cite{BlockedSinkarovs}, and
provides a basis on which tensors can be discussed
\end{AgdaAlign}
\subsubsection{Tensor length}

Given the shape of an array, we can compute the number of elements it contains
by multiplying all components of the shape tree

\begin{code}%
%
\>[2]\AgdaFunction{\#}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Shape}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
%
\>[2]\AgdaFunction{\#}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
%
\>[2]\AgdaFunction{\#}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaBound{s₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{\#}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{*}}\AgdaSpace{}%
\AgdaFunction{\#}\AgdaSpace{}%
\AgdaBound{s₁}\<%
\end{code}

When computing the DFT and FFT, the number of elements in a given tensor is used 
to determine the base, or principal, root of unity.
This base, however, cannot be zero as to avoid division be zero.
Therefore, \AF{ω} requires that a non zero proof argument to be provided.\ref{para:roots_of_unity}.
This can be easily achieved by restricting the DFT and FFT to operate only on
tensors the number of elements is greater than zero,
This means that any implementation of the DFT and FFT must be provided, or generate,
a proof argument that no leaf is of zero length.
For the simplicity of this paper we use the notation $Ar∔$ % Judge me how you will for using this symbol here and then changing what it really is in newunicodechar... its cursed, its horrible... but it works
to indicate that a tensor is provided such a proof argument.
This notation cannot be used in the final implementation where the non zero property
must be provided explicitly, however, this obfuscates the key points and so this improved
notation is used here.


\subsubsection{One-dimensional tensors}
Given the definition of tensors, we can begin by defining some basic operations 
which can be used upon them.
The first operations we shall define will operate exclusively on single dimensional
tensors, which are often referred to for succinctness as vectors.

\paragraph{Head and Tail} Head and tail operations can be defined to 
allow for the deconstruction of any tensor of shape \AF{ι (suc n)}. 
\AF{head₁} returns the first element of the tensor, while
\AF{tail₁} returns all following elements in a tensor of shape \AF{ι n}.
These operations allow for recursion over vectors to be defined.

\begin{code}%
%
\>[2]\AgdaFunction{head₁}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{X}\<%
\\
%
\>[2]\AgdaFunction{head₁}\AgdaSpace{}%
\AgdaBound{ar}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaInductiveConstructor{fzero}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{tail₁}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{X}\<%
\\
%
\>[2]\AgdaFunction{tail₁}\AgdaSpace{}%
\AgdaBound{ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{fsuc}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{))}\<%
\end{code}

% This wouldn't be good for a paper, but I feel like its useful to observe when
% describing for the thesis
One feature of Agda used regularly is seen here, pattern matching.
This is a feature found in most functional languages that use algebraic types,
such as Haskell, and allows for the breaking down of some types of input 
fields to the types they are built on. 
In the above example \AF{ι x} is of type \AF{Position (suc n)}, 
which is deconstructed to expose \AF{x} of type \AF{Fin (suc n)}.

\paragraph{Sum} From Equation \ref{eq:DFT_Definition}, it can be seen that
an operation to sum all elements in a given array is required.
By defining this operation generally, over any binary operation and neutral 
element, we are able to represent any fold-like operations including the sum
operation we require.
This definition is can be instantiated for any commutative monoid 
\AF{(X, \_⋆\_, ε)} where 
\begin{itemize}
  \item \AF{X} is a set
  \item \AF{\_⋆\_} is some operation \AF{X → X → X}, such that 
  \begin{itemize}
      \item \AF{x ⋆ y ≡ y ⋆ x}
      \item \AF{(x ⋆ y) ⋆ z ≡ x ⋆ (y ⋆ z)}
  \end{itemize}
  \item \AF{ε} is an identity element in \AF{X} such that \AF{ε ⋆ x ≡ x}
\end{itemize}
With the above definition, sum can be defined as below.
\begin{AgdaMultiCode}
\begin{code}%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{Sum}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSymbol{\}}\<%
\\
%
\>[4]\AgdaSymbol{(}\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⋆\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Op₂}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaSymbol{(}\AgdaBound{ε}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaSymbol{(}\AgdaBound{isCommutativeMonoid}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{IsCommutativeMonoid}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{A}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≡\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⋆\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{ε}\AgdaSymbol{)}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{where}\<%
\end{code}
%TC:ignore
\begin{code}[hide]%
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Product.Base}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{proj₁}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{proj₂}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Nat.Base}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{ℕ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}*\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Nat.Properties}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{*-zeroʳ}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Fin.Base}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{()}\AgdaSpace{}%
\AgdaKeyword{renaming}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaInductiveConstructor{fzero}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaInductiveConstructor{fsuc}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Matrix}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Ar}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaDatatype{Position}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{ι}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{head₁}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{tail₁}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{splitArₗ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{splitArᵣ}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Matrix.Equality}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≅\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{reduce-≅}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Matrix.Properties}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{tail₁-const}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Matrix.Reshape}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{reshape}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{reindex}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{|s|≡|sᵗ|}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⟨\AgdaUnderscore{}⟩}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{split}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}∙\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{eq}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaComment{-----------------------------------------}\<%
\\
%
\>[2]\AgdaComment{---\ Pull\ out\ properties\ of\ the\ monoid\ ---}\<%
\\
%
\>[2]\AgdaComment{-----------------------------------------}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{AlgebraDefinitions}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{A}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≡\AgdaUnderscore{}}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{IsCommutativeMonoid}\AgdaSpace{}%
\AgdaBound{isCommutativeMonoid}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{identity}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{assoc}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{comm}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaKeyword{private}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{identityˡ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{LeftIdentity}\AgdaSpace{}%
\AgdaBound{ε}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⋆\AgdaUnderscore{}}}\<%
\\
%
\>[4]\AgdaFunction{identityˡ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaField{proj₁}\AgdaSpace{}%
\AgdaFunction{identity}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[4]\AgdaFunction{identityʳ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{RightIdentity}\AgdaSpace{}%
\AgdaBound{ε}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{\AgdaUnderscore{}⋆\AgdaUnderscore{}}}\<%
\\
%
\>[4]\AgdaFunction{identityʳ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaField{proj₂}\AgdaSpace{}%
\AgdaFunction{identity}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[4]\AgdaKeyword{variable}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaGeneralizable{n}\AgdaSpace{}%
\AgdaGeneralizable{m}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaComment{----------------------}\<%
\\
%
\>[2]\AgdaComment{---\ Sum\ Definition\ ---}\<%
\\
%
\>[2]\AgdaComment{----------------------}\<%
\\
\>[0]\<%
\end{code}
%TC:endignore
\begin{code}%
\>[0][@{}l@{\AgdaIndent{1}}]%
\>[2]\AgdaFunction{sum}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
%
\>[2]\AgdaFunction{sum}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{zero}\AgdaSymbol{\}}%
\>[15]\AgdaBound{xs}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{ε}\<%
\\
%
\>[2]\AgdaFunction{sum}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{\}}%
\>[15]\AgdaBound{xs}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{head₁}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaBound{⋆}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{sum}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaFunction{tail₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{xs}\<%
\end{code}
\end{AgdaMultiCode}
For the DFT and FFT in this paper, this is instantiated over complex addition,
described as the monoid \AF{(ℂ, \_+\_, 0ℂ)}.
However, this definition allows for any fold-like operation to be defined for 
any instance of \AF{(X, \_⋆\_, ε)} meaning operations such as $\Pi$ can be 
instantiated with the same definition and general rules.
This is similar to how the DFT and FFT can be instantiated for any definition of
\AF{Cplx}.


%TC:ignore
\begin{code}[hide]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Complex}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaRecord{Cplx}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{FFT}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{real}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Real}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{cplx}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cplx}\AgdaSpace{}%
\AgdaBound{real}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Cplx}\AgdaSpace{}%
\AgdaBound{cplx}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{ℂ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaField{\AgdaUnderscore{}*\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{-ω}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaField{e\textasciicircum{}i\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaField{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{0ℂ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{+-*-isCommutativeRing}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{AlgebraStructures}%
\>[26]\AgdaSymbol{\{}\AgdaArgument{A}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaField{ℂ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≡\AgdaUnderscore{}}}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{IsCommutativeRing}\AgdaSpace{}%
\AgdaField{+-*-isCommutativeRing}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{+-isCommutativeMonoid}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Fin.Base}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{Fin}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{toℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{renaming}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaInductiveConstructor{fzero}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaInductiveConstructor{fsuc}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Nat.Base}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{ℕ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaRecord{NonZero}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{renaming}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}+ₙ\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}*\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}*ₙ\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Nat.Properties}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{nonZero?}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Nullary}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Matrix}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Ar}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaDatatype{Shape}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaDatatype{Position}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{ι}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{zipWith}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{mapLeft}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{length}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Matrix.Sum}\AgdaSpace{}%
\AgdaOperator{\AgdaField{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaFunction{0ℂ}\AgdaSpace{}%
\AgdaFunction{+-isCommutativeMonoid}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{sum}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Matrix.Reshape}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{recursive-transpose}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{reshape}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{swap}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⟨\AgdaUnderscore{}⟩}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{♯}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{recursive-transposeᵣ}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Matrix.NonZero}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{NonZeroₛ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{ι}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{nonZeroₛ-s⇒nonZero-s}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{nonZeroDec}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{nonZeroₛ-s⇒nonZeroₛ-sᵗ}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaKeyword{private}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaKeyword{variable}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaGeneralizable{N}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
%
\>[6]\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Shape}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{Ar∔}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Shape}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
%
\>[2]\AgdaFunction{Ar∔}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Ar}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaComment{------------------------------------}\<%
\\
%
\>[2]\AgdaComment{---\ DFT\ and\ FFT\ helper\ functions\ ---}\<%
\\
%
\>[2]\AgdaComment{------------------------------------}\<%
\end{code}
%TC:endignore

\paragraph{Index's in a single dimension}. As defined above, \AF{Position} encodes 
the bounds on a given index, as well as the index itself. 
When calculating the DFT some arithmetic on this index is required,
this arithmetic would be overly complex if performed while the index is 
wrapped in a position, and so
helper functions are required to convert a given position to its index value.
This helper function for the single dimensional case is shown below.

\begin{code}%
%
\>[2]\AgdaFunction{iota}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaGeneralizable{N}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
%
\>[2]\AgdaFunction{iota}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{toℕ}\AgdaSpace{}%
\AgdaBound{i}\<%
\end{code}

\subsection{DFT}
Given the above definition of the complex numbers, tensors, and methods on one 
dimensional tensors, the formation of the DFT is now trivial.
This is of the same shape as Equation \ref{eq:DFT_Definition}, requiring through 
use of \AF{Ar∔} that the length of any input vector is non zero, as to satisfy 
this same condition on the divisor of \AF{-ω} as defined in \ref{para:roots_of_unity}.

\begin{code}%
%
\>[2]\AgdaFunction{DFT}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Ar∔}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaGeneralizable{N}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaField{ℂ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar∔}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaGeneralizable{N}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaField{ℂ}\<%
\\
%
\>[2]\AgdaFunction{DFT}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{N}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaBound{j}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{sum}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{k}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSpace{}%
\AgdaBound{k}\AgdaSpace{}%
\AgdaOperator{\AgdaField{*}}\AgdaSpace{}%
\AgdaField{-ω}\AgdaSpace{}%
\AgdaBound{N}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{iota}\AgdaSpace{}%
\AgdaBound{k}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{*ₙ}}\AgdaSpace{}%
\AgdaFunction{iota}\AgdaSpace{}%
\AgdaBound{j}\AgdaSymbol{)}\<%
\end{code}
%TC:ignore
\begin{code}[hide]%
\>[2][@{}l@{\AgdaIndent{1}}]%
\>[4]\AgdaKeyword{where}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaKeyword{postulate}\<%
\\
\>[6][@{}l@{\AgdaIndent{0}}]%
\>[8]\AgdaKeyword{instance}\<%
\\
\>[8][@{}l@{\AgdaIndent{0}}]%
\>[10]\AgdaPostulate{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{NonZero}\AgdaSpace{}%
\AgdaBound{N}\<%
\end{code}
%TC:endignore


% It is then trivial to form the \AF{DFT} without this restriction, by 
% checking if a given array is of length zero, and returning that same array of
% length zero when this is the case.



\subsection{Reshape}
%TC:ignore
\begin{code}[hide]%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{Reshape}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Nat}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{ℕ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}*\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaRecord{NonZero}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Nat.Properties}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{*-comm}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Fin}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{F}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{Fin}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{combine}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{remQuot}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{quotRem}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{toℕ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{cast}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Fin.Properties}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{remQuot-combine}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{combine-remQuot}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{cast-is-id}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{cast-trans}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Product}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{proj₁}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{proj₂}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Matrix}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{Shape}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaDatatype{Position}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{ι}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{length}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Binary.PropositionalEquality}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{Eq}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Eq}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≡\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{cong}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{trans}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{subst}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{sym}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Eq.≡-Reasoning}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaKeyword{variable}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaGeneralizable{m}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSpace{}%
\AgdaGeneralizable{k}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
%
\>[4]\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaGeneralizable{q}\AgdaSpace{}%
\AgdaGeneralizable{r}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Shape}\<%
\\
%
\>[4]\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaGeneralizable{Y}\AgdaSpace{}%
\AgdaGeneralizable{Z}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaKeyword{infixr}\AgdaSpace{}%
\AgdaNumber{5}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}∙\AgdaUnderscore{}}}\<%
\\
%
\>[2]\AgdaKeyword{infixl}\AgdaSpace{}%
\AgdaNumber{10}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}⊕\AgdaUnderscore{}}}\<%
\end{code}
%TC:endignore

When working with tensors, it is often necessary for elements to be rearranged, 
through operations such as transpose or flatten, without any additions or removals.
The naïve approach to this, would be to define each rearrange as a function of type \AF{Ar s X → Ar p X}.
This approach however, would operate on too large a space, meaning reasoning upon
such functions would be difficult and could not be generalised.
An alternate approach is to define a small language of reshapes.
This language captures a small set of rearrangements, as well as methods to allow
for their composition.
Generalised properties, such as how each reshape is applied to a position, can 
then be defined on this language or reshapes.

For this language, each reshape operations can be considered as a bijective function
from shape \AF{s} to shape \AF{p}. 
As this ensures that no tensor can loose or gain data, creating a strict reshape 
language will strengthen any reasoning in future proofs.
This also means that any reshape operation is reversible which will allow for the
formation of rules which are general to all operations in the reshape language.

The reshape language is defined as a set of operations from shape to shape as follows.
\begin{code}%
%
\>[2]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Reshape}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Shape}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Shape}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{eq}%
\>[11]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Reshape}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{s}%
\>[46]\AgdaComment{--\ Identity}\<%
\\
%
\>[4]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}∙\AgdaUnderscore{}}}%
\>[11]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Reshape}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaGeneralizable{q}%
\>[46]\AgdaComment{--\ Composition\ of\ Reshapes}\<%
\\
%
\>[11]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Reshape}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{p}\<%
\\
%
\>[11]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Reshape}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{q}\<%
\\
%
\>[4]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}⊕\AgdaUnderscore{}}}%
\>[11]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Reshape}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{p}%
\>[46]\AgdaComment{--\ Left/\ Right\ application}\<%
\\
%
\>[11]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Reshape}\AgdaSpace{}%
\AgdaGeneralizable{q}\AgdaSpace{}%
\AgdaGeneralizable{r}\<%
\\
%
\>[11]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Reshape}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaGeneralizable{q}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaGeneralizable{r}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaInductiveConstructor{split}%
\>[11]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Reshape}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{m}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{*}}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaGeneralizable{m}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSymbol{)}%
\>[46]\AgdaComment{--\ "Vector"\ →\ 2D\ Tensor}\<%
\\
%
\>[4]\AgdaInductiveConstructor{flat}%
\>[11]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Reshape}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaGeneralizable{m}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{m}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{*}}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSymbol{))}%
\>[46]\AgdaComment{--\ 2D\ Tensor\ →\ "Vector"}\<%
\\
%
\>[4]\AgdaInductiveConstructor{swap}%
\>[11]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Reshape}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSymbol{)}%
\>[46]\AgdaComment{--\ Transposition}\<%
\end{code}

Using this definition of reshape and some standard library methods on Fin, 
it is then possible do define the application of reshape to positions and tensors.
\begin{code}%
%
\>[2]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⟨\AgdaUnderscore{}⟩}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Position}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Reshape}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Position}\AgdaSpace{}%
\AgdaGeneralizable{s}\<%
\\
%
\>[2]\AgdaBound{i}%
\>[15]\AgdaOperator{\AgdaFunction{⟨}}\AgdaSpace{}%
\AgdaInductiveConstructor{eq}%
\>[25]\AgdaOperator{\AgdaFunction{⟩}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{i}\<%
\\
%
\>[2]\AgdaBound{i}%
\>[15]\AgdaOperator{\AgdaFunction{⟨}}\AgdaSpace{}%
\AgdaBound{r}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∙}}\AgdaSpace{}%
\AgdaBound{r₁}%
\>[25]\AgdaOperator{\AgdaFunction{⟩}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟨}}\AgdaSpace{}%
\AgdaBound{r}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟨}}\AgdaSpace{}%
\AgdaBound{r₁}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\<%
\\
%
\>[2]\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaBound{j}\AgdaSymbol{)}%
\>[15]\AgdaOperator{\AgdaFunction{⟨}}\AgdaSpace{}%
\AgdaBound{r}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊕}}\AgdaSpace{}%
\AgdaBound{r₁}%
\>[25]\AgdaOperator{\AgdaFunction{⟩}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟨}}\AgdaSpace{}%
\AgdaBound{r}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{j}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟨}}\AgdaSpace{}%
\AgdaBound{r₁}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaBound{j}\AgdaSymbol{)}%
\>[15]\AgdaOperator{\AgdaFunction{⟨}}\AgdaSpace{}%
\AgdaInductiveConstructor{split}%
\>[25]\AgdaOperator{\AgdaFunction{⟩}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{combine}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaBound{j}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaBound{i}%
\>[15]\AgdaOperator{\AgdaFunction{⟨}}\AgdaSpace{}%
\AgdaInductiveConstructor{flat}%
\>[25]\AgdaOperator{\AgdaFunction{⟩}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaKeyword{let}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{remQuot}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaKeyword{in}\AgdaSpace{}%
\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaBound{b}\<%
\\
%
\>[2]\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaBound{j}\AgdaSymbol{)}%
\>[15]\AgdaOperator{\AgdaFunction{⟨}}\AgdaSpace{}%
\AgdaInductiveConstructor{swap}%
\>[25]\AgdaOperator{\AgdaFunction{⟩}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{j}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaBound{i}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{reshape}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Reshape}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaGeneralizable{X}\<%
\\
%
\>[2]\AgdaFunction{reshape}\AgdaSpace{}%
\AgdaBound{r}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{ix}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ix}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟨}}\AgdaSpace{}%
\AgdaBound{r}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\AgdaSpace{}%
\AgdaSymbol{)}\<%
\end{code}
\subsubsection{Reverse}
As each reshape operation is a bijective function, it is trivial to define a reverse
method.
\begin{code}%
%
\>[2]\AgdaFunction{rev}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Reshape}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Reshape}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaGeneralizable{s}\<%
\\
%
\>[2]\AgdaFunction{rev}\AgdaSpace{}%
\AgdaInductiveConstructor{eq}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{eq}\<%
\\
%
\>[2]\AgdaFunction{rev}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{r}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊕}}\AgdaSpace{}%
\AgdaBound{r₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{rev}\AgdaSpace{}%
\AgdaBound{r}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊕}}\AgdaSpace{}%
\AgdaFunction{rev}\AgdaSpace{}%
\AgdaBound{r₁}\<%
\\
%
\>[2]\AgdaFunction{rev}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{r}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∙}}\AgdaSpace{}%
\AgdaBound{r₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{rev}\AgdaSpace{}%
\AgdaBound{r₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∙}}\AgdaSpace{}%
\AgdaFunction{rev}\AgdaSpace{}%
\AgdaBound{r}\<%
\\
%
\>[2]\AgdaFunction{rev}\AgdaSpace{}%
\AgdaInductiveConstructor{split}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{flat}\<%
\\
%
\>[2]\AgdaFunction{rev}\AgdaSpace{}%
\AgdaInductiveConstructor{flat}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{split}\<%
\\
%
\>[2]\AgdaFunction{rev}\AgdaSpace{}%
\AgdaInductiveConstructor{swap}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{swap}\<%
\end{code}
From this operation, rules on reshape can be defined, allow for formation of
relations between reshape operations.
This allows for the reduction of the reshape language when operations such as 
\AF{split ∙ flat} occur.
%TC:ignore
\begin{code}[hide]%
%
\>[2]\AgdaKeyword{infixl}\AgdaSpace{}%
\AgdaNumber{11}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}ᵗ}}\<%
\\
%
\>[2]\AgdaKeyword{postulate}\<%
\end{code}
%TC:endignore
\begin{code}%
\>[2][@{}l@{\AgdaIndent{1}}]%
\>[4]\AgdaPostulate{rev-eq}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaSymbol{∀}%
\>[937I]\AgdaSymbol{(}\AgdaBound{r}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Reshape}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSymbol{)}\<%
\\
\>[.][@{}l@{}]\<[937I]%
\>[8]\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Position}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaSymbol{)}\<%
\\
%
\>[6]\AgdaComment{---------------------}\<%
\\
%
\>[6]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟨}}\AgdaSpace{}%
\AgdaBound{r}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∙}}\AgdaSpace{}%
\AgdaFunction{rev}\AgdaSpace{}%
\AgdaBound{r}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{i}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[4]\AgdaPostulate{rev-rev}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaSymbol{∀}%
\>[956I]\AgdaSymbol{(}\AgdaBound{r}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Reshape}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSymbol{)}\<%
\\
\>[.][@{}l@{}]\<[956I]%
\>[8]\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Position}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaSymbol{)}\<%
\\
%
\>[6]\AgdaComment{-----------------------------}\<%
\\
%
\>[6]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟨}}\AgdaSpace{}%
\AgdaFunction{rev}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{rev}\AgdaSpace{}%
\AgdaBound{r}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟨}}\AgdaSpace{}%
\AgdaBound{r}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\<%
\end{code}

\subsubsection{Recursive Reshaping}
While the above operations of reshape can be applied to tensors of a fixed shape
this language of reshapes can be improved with the creation of recursive reshape
operations.

\paragraph{Flatten and Unflatten} enable the recursive application of flat and 
split respectively.
This allows for an $N$-dimensional tensor to be flattened, and for any single dimensional
tensor of size \AF{length s} to be unflattened into a tensor of shape s.
\begin{code}%
%
\>[2]\AgdaFunction{♭}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Reshape}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{length}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSymbol{))}\<%
\\
%
\>[2]\AgdaFunction{♭}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaBound{x}%
\>[11]\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{eq}\<%
\\
%
\>[2]\AgdaFunction{♭}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaBound{s₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{flat}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∙}}\AgdaSpace{}%
\AgdaFunction{♭}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊕}}\AgdaSpace{}%
\AgdaFunction{♭}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaComment{--\ Unflatten\ is\ free\ from\ flatten}\<%
\\
%
\>[2]\AgdaFunction{♯}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Reshape}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{length}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaGeneralizable{s}\<%
\\
%
\>[2]\AgdaFunction{♯}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{rev}\AgdaSpace{}%
\AgdaFunction{♭}\<%
\end{code}

\paragraph{Transpose} flips a tensor over its diagonal by swapping the left and
right sub-shape at each level.
Transpose applies swap to any non leaf nodes, allowing for any given 
function designed to operate on multi dimensional tenors, such as the FFT, to
do the same swap at each level.
It can be seen below that transpose is defined through use of the postfix operator, 
meaning the input shape goes before \AF{ᵗ}
\begin{code}%
%
\>[2]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}ᵗ}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Shape}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Shape}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}ᵗ}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaBound{x}%
\>[12]\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}ᵗ}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaBound{s₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s₁}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{ᵗ}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{ᵗ}}\AgdaSymbol{)}\<%
\end{code}


\subsection{Operations on tensors of Arbitrary rank}
In addition to the above reshape operations, some methods which can operate 
directly on multi dimensional tensors are required.
\paragraph{Zip With}\label{para:zipWith} performs point-wise application of a 
given function \AF{f} over two tensors of the same shape. 
%TC:ignore
\begin{code}[hide]%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{Matrix2}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Matrix}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Ar}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaDatatype{Shape}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaDatatype{Position}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{private}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaKeyword{variable}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaGeneralizable{Y}\AgdaSpace{}%
\AgdaGeneralizable{Z}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
%
\>[6]\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Shape}\<%
\end{code}
%TC:endignore
\begin{code}%
%
\>[2]\AgdaFunction{zipWith}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{Y}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{Z}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{Y}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{Z}\<%
\\
%
\>[2]\AgdaFunction{zipWith}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{arr₁}\AgdaSpace{}%
\AgdaBound{arr₂}\AgdaSpace{}%
\AgdaBound{pos}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{arr₁}\AgdaSpace{}%
\AgdaBound{pos}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{arr₂}\AgdaSpace{}%
\AgdaBound{pos}\AgdaSymbol{)}\<%
\end{code}
This has many uses, below is shown one example where zipWith is used
over tensors $x$ and $y$, of shape \AF{(ι n ⊗ ι m)},
to add the values at each position.
This two dimensional shape is defined arbitrarily for ease of readability, 
however, \AF{zipWith} is not restricted on the shape meaning a tensor of any shape can
be used.

\begin{displaymath}
  \text{zipWith  \_+\_}
  \begin{bmatrix}
    x_{1,1} & \dots  & x_{1,n} \\
    \vdots  & \ddots & \vdots \\
    x_{m,1} & \dots  & x_{m,n}
  \end{bmatrix}
  \begin{bmatrix}
    y_{1,1} & \dots  & y_{1,n} \\
    \vdots  & \ddots & \vdots \\
    y_{m,1} & \dots  & y_{m,n}
  \end{bmatrix}
  \equiv 
  \begin{bmatrix}
    x_{1,1} + y_{1,1} & \dots  & x_{1,n} + y_{1,n} \\
    \vdots                  & \ddots & \vdots \\
    x_{m,1} + y_{m,1} & \dots  & x_{m,n} + y_{m,n}
  \end{bmatrix}
\end{displaymath}


\paragraph{Map} is similar to \AF{zipWith}, but operates over only one tensor, 
applying a function \AF{f} to each element.
\begin{code}%
%
\>[2]\AgdaFunction{map}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{Y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{Y}\<%
\\
%
\>[2]\AgdaFunction{map}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{arr}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{arr}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\<%
\end{code}
The functions \AF{nest} and \AF{unnest} can then be defined to create an 
isomorphism between tensors of the form \AF{Ar (s ⊗ p) X} and nested tensors 
of the form \AF{A s (Ar p X)}.
This allows for the definition of a new function \AF{mapLeft} which can apply a
given function to each \AF{p} shaped sub tensor.

\begin{code}%
%
\>[2]\AgdaFunction{nest}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaFunction{nest}\AgdaSpace{}%
\AgdaBound{arr}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaBound{j}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{arr}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaBound{j}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{unnest}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{X}\<%
\\
%
\>[2]\AgdaFunction{unnest}\AgdaSpace{}%
\AgdaBound{arr}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaBound{j}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{arr}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaBound{j}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{mapLeft}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{s}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaBound{t}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Shape}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaBound{t}\AgdaSpace{}%
\AgdaGeneralizable{Y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaBound{p}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaBound{t}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{Y}\<%
\\
%
\>[2]\AgdaFunction{mapLeft}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{arr}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{unnest}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{map}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{nest}\AgdaSpace{}%
\AgdaBound{arr}\AgdaSymbol{))}\<%
\end{code}


\clearpage
\subsection{FFT}
Given the above operations, it is now possible to begin forming a definition for
the FFT.

Looking at the basic derivation of the Cooley Tukey FFT over an input vector
defined in Equation \ref{eq:FFTDefinitionFromDFT}, three distinct sections can
be observed.
\begin{align}
    X_{j_1r_1+j_0}
      &=\underbrace{\sum^{r_2-1}_{k_0=0}{
        \left[
          \underbrace{
            \left(
              \underbrace{
                \sum^{r_1-1}_{k_1=0}x_{k_1r_2+k_0}\omega_{r_1}^{k_1j_0}
              }_{Section A} \right
            ) \omega_{r_1r_2}^{k_0j_1}
          }_{Section B}
        \right]
        \omega_{r_2}^{k_0j_1}
      }}_{Section C}
    \label{eq:FFTDefinitionLabeled}
\end{align}
Section A takes the form of a DFT of length $r_1$.
In vector form, the first element of the input for this DFT is located at index $k₀$, 
each subsequent input is then found taken by making a step of $r_2$, $r_1$ times.
In vector form this is a relatively complex input to reason upon, when we can 
instead consider our input in tensor form, initially, as a tensor of shape \AF{ι r₁ ⊗ ι r₂}.
In this form, Section A can be considered to apply the DFT to each column of the
input tensor.
Similar to Section A, Section C then takes the form of a DFT of length $r_2$.
In our \AF{ι r₁ ⊗ ι r₂} tensor form, this is equivalent to the application of 
the DFT over the rows of the result of section B.

Section B differs to section A and C, and applies what are generally referred to
as, the twiddle factors.
In tensor form this section is equivalent to a point wise multiplication 
over each element from Section A.
This step can be represented in Agda as \AF{zipWith \_*\_}, on a tensor containing 
these "twiddle factors".

%TC:ignore
\begin{code}[hide]%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{FFT2}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{real}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Real}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{cplx}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Cplx}\AgdaSpace{}%
\AgdaBound{real}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Matrix}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Ar}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaDatatype{Shape}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaDatatype{Position}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{ι}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{length}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{mapLeft}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{zipWith}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Matrix.NonZero}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Matrix.Reshape}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⟨\AgdaUnderscore{}⟩}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{♯}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{reshape}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{swap}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{renaming}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{recursive-transpose}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaFunction{\AgdaUnderscore{}ᵗ}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{FFT}\AgdaSpace{}%
\AgdaBound{real}\AgdaSpace{}%
\AgdaBound{cplx}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{iota}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{renaming}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{DFT′}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaFunction{DFT}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Nat.Base}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{()}\AgdaSpace{}%
\AgdaKeyword{renaming}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}*\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}*ₙ\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Cplx}\AgdaSpace{}%
\AgdaBound{cplx}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{ℂ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaField{\AgdaUnderscore{}*\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{-ω}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaField{e\textasciicircum{}i\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaField{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{0ℂ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{+-*-isCommutativeRing}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaKeyword{private}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaKeyword{variable}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Shape}\<%
\\
%
\>[6]\AgdaGeneralizable{r₁}\AgdaSpace{}%
\AgdaGeneralizable{r₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{Ar∔}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Shape}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
%
\>[2]\AgdaFunction{Ar∔}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Ar}\<%
\end{code}
%TC:endignore
\begin{code}%
%
\>[2]\AgdaFunction{2D-twiddles}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Ar∔}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaGeneralizable{r₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaGeneralizable{r₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaField{ℂ}\<%
\\
%
\>[2]\AgdaFunction{2D-twiddles}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{r₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{r₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{k₀}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaBound{j₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaField{-ω}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{r₂}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{*ₙ}}\AgdaSpace{}%
\AgdaBound{r₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{iota}\AgdaSpace{}%
\AgdaBound{k₀}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{*ₙ}}\AgdaSpace{}%
\AgdaFunction{iota}\AgdaSpace{}%
\AgdaBound{j₁}\AgdaSpace{}%
\AgdaSymbol{)}\<%
\end{code}
%TC:ignore
\begin{code}[hide]%
\>[2][@{}l@{\AgdaIndent{1}}]%
\>[6]\AgdaKeyword{where}\<%
\\
\>[6][@{}l@{\AgdaIndent{0}}]%
\>[8]\AgdaKeyword{postulate}\<%
\\
\>[8][@{}l@{\AgdaIndent{0}}]%
\>[10]\AgdaKeyword{instance}\<%
\\
\>[10][@{}l@{\AgdaIndent{0}}]%
\>[12]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{NonZero}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{r₂}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{*ₙ}}\AgdaSpace{}%
\AgdaBound{r₁}\AgdaSymbol{)}\<%
\end{code}
%TC:endignore

It can be seen here that when computing these twiddle factors, the number of 
elements in the input vector is used as the base value.
It is defined previously that this base value cannot be zero, and so this 
step imposes the requirement that the FFT can only operate upon tensors with one or more elements.

Using this twiddle tensor, the definition for the two dimensional FFT is generated
by forming each section into its own step.
Of note in the definition below are the three uses of swap.
The first swap allows DFT′ to map over the columns of the input array,
while the next inverts this and allows map to be performed over the rows.
The final swap is performed because, given an input in row major order, the 
result of the FFT is produced in column major order. 
For this to be represented correctly when flatten, \AF{♭}, is applied the output
tensor must be transposed, this is performed over two dimensions with \AF{swap}.
Because of this third swap, the shape of the output tensor is transposed, as
indicated to in the function type by \AF{ᵗ}.

\begin{code}%
%
\>[2]\AgdaFunction{2D-FFT}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Ar∔}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaGeneralizable{r₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaGeneralizable{r₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaField{ℂ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar∔}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaGeneralizable{r₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaGeneralizable{r₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{ᵗ}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaField{ℂ}\<%
\\
%
\>[2]\AgdaFunction{2D-FFT}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{r₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{r₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{arr}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaKeyword{let}\<%
\\
\>[6][@{}l@{\AgdaIndent{0}}]%
\>[10]\AgdaBound{innerDFTapplied}%
\>[33]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{mapLeft}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{DFT}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{r₁}\AgdaSymbol{\})}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{reshape}\AgdaSpace{}%
\AgdaInductiveConstructor{swap}\AgdaSpace{}%
\AgdaBound{arr}\AgdaSymbol{)}\<%
\\
%
\>[10]\AgdaBound{twiddleFactorsApplied}%
\>[33]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{zipWith}\AgdaSpace{}%
\AgdaOperator{\AgdaField{\AgdaUnderscore{}*\AgdaUnderscore{}}}%
\>[49]\AgdaBound{innerDFTapplied}\AgdaSpace{}%
\AgdaFunction{2D-twiddles}\<%
\\
%
\>[10]\AgdaBound{outerDFTapplied}%
\>[33]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{mapLeft}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{DFT}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{r₂}\AgdaSymbol{\})}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{reshape}\AgdaSpace{}%
\AgdaInductiveConstructor{swap}\AgdaSpace{}%
\AgdaBound{twiddleFactorsApplied}\AgdaSymbol{)}\<%
\\
%
\>[6]\AgdaKeyword{in}%
\>[10]\AgdaFunction{reshape}\AgdaSpace{}%
\AgdaInductiveConstructor{swap}\AgdaSpace{}%
\AgdaBound{outerDFTapplied}\<%
\end{code}
%TC:ignore
\begin{code}[hide]%
%
\>[6]\AgdaKeyword{where}\<%
\\
\>[6][@{}l@{\AgdaIndent{0}}]%
\>[8]\AgdaKeyword{postulate}\<%
\\
\>[8][@{}l@{\AgdaIndent{0}}]%
\>[10]\AgdaKeyword{instance}\<%
\\
\>[10][@{}l@{\AgdaIndent{0}}]%
\>[12]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{NonZero}\AgdaSpace{}%
\AgdaBound{r₁}\<%
\\
%
\>[12]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{NonZero}\AgdaSpace{}%
\AgdaBound{r₂}\<%
\\
%
\>[12]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NonZeroₛ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaBound{r₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaBound{r₁}\AgdaSymbol{)}\<%
\end{code}
%TC:endignore

\begin{AgdaAlign}

Given knowledge that the DFT should be equivalent to the FFT, the two dimensional
definition can then be improved by instead applying the FFT at each step.
This requires the slight modification of the 2D-FFT implementation such that it 
accepts a tensor of any shape \AF{s} as input.

The definition for the twiddle factors must also be redefined, such that twiddles
can be computed for any shape with more than two dimensions.
It is easy to see, that the previous base of the roots of unity, $r₁\times r₂$,
maps directly to the \AF{length} of any given tensor.
To calculate the power of the root of unity, we can define \AF{offset-prod}.
This flattens the values of \AF{k} and \AF{j}, before multiplying them together to
calculate the power.
\begin{code}%
%
\>[2]\AgdaFunction{offset-prod}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Position}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
%
\>[2]\AgdaFunction{offset-prod}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{k}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaBound{j}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{iota}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{k}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟨}}\AgdaSpace{}%
\AgdaFunction{♯}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{*ₙ}}\AgdaSpace{}%
\AgdaFunction{iota}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{j}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟨}}\AgdaSpace{}%
\AgdaFunction{♯}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟩}}\AgdaSymbol{)}\<%
\\
\>[0]\<%
\\
%
\>[2]\AgdaFunction{twiddles}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Ar∔}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaField{ℂ}\<%
\\
%
\>[2]\AgdaFunction{twiddles}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{s}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{p}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaField{-ω}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{length}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaBound{p}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{offset-prod}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\<%
\end{code}
%TC:ignore
\begin{code}[hide]%
\>[2][@{}l@{\AgdaIndent{1}}]%
\>[6]\AgdaKeyword{where}\<%
\\
\>[6][@{}l@{\AgdaIndent{0}}]%
\>[8]\AgdaKeyword{postulate}\<%
\\
\>[8][@{}l@{\AgdaIndent{0}}]%
\>[10]\AgdaKeyword{instance}\<%
\\
\>[10][@{}l@{\AgdaIndent{0}}]%
\>[12]\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{NonZero}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{length}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{*ₙ}}\AgdaSpace{}%
\AgdaFunction{length}\AgdaSpace{}%
\AgdaBound{p}\AgdaSymbol{)}\<%
\end{code}
%TC:endignore
\end{AgdaAlign}

The definition of this general twiddle tensor now allows for FFT to be defined
for an input of any shape.
The same problem of the output shape must then be dealt with again.
As the result of the FFT is in column major order, the result must be transposed
for flatten to represent it correctly.
This can be achieved through the application of \AF{swap} to \AF{outerDFTapplied}
before returning, as each sub tensor is the result of the application of the FFT and
will be transposed.

\begin{AgdaSuppressSpace}
\begin{code}%
%
\>[2]\AgdaFunction{FFT}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Ar∔}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaField{ℂ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar∔}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{ᵗ}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaField{ℂ}\<%
\\
%
\>[2]\AgdaFunction{FFT}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaBound{N}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{arr}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{DFT}\AgdaSpace{}%
\AgdaBound{arr}\<%
\end{code}
%TC:ignore
\begin{code}[hide]%
\>[2][@{}l@{\AgdaIndent{1}}]%
\>[4]\AgdaKeyword{where}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaKeyword{postulate}\<%
\\
\>[6][@{}l@{\AgdaIndent{0}}]%
\>[8]\AgdaKeyword{instance}\<%
\\
\>[8][@{}l@{\AgdaIndent{0}}]%
\>[10]\AgdaPostulate{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{NonZero}\AgdaSpace{}%
\AgdaBound{N}\<%
\end{code}
%TC:endignore
\begin{code}%
%
\>[2]\AgdaFunction{FFT}%
\>[1381I]\AgdaSymbol{\{}\AgdaBound{r₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaBound{r₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{arr}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[.][@{}l@{}]\<[1381I]%
\>[6]\AgdaKeyword{let}\<%
\\
\>[6][@{}l@{\AgdaIndent{0}}]%
\>[10]\AgdaBound{innerDFTapplied}%
\>[33]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{mapLeft}\AgdaSpace{}%
\AgdaFunction{FFT}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{reshape}\AgdaSpace{}%
\AgdaInductiveConstructor{swap}\AgdaSpace{}%
\AgdaBound{arr}\AgdaSymbol{)}\<%
\\
%
\>[10]\AgdaBound{twiddleFactorsApplied}%
\>[33]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{zipWith}\AgdaSpace{}%
\AgdaOperator{\AgdaField{\AgdaUnderscore{}*\AgdaUnderscore{}}}%
\>[49]\AgdaBound{innerDFTapplied}\AgdaSpace{}%
\AgdaFunction{twiddles}\<%
\\
%
\>[10]\AgdaBound{outerDFTapplied}%
\>[33]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{mapLeft}\AgdaSpace{}%
\AgdaFunction{FFT}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{reshape}\AgdaSpace{}%
\AgdaInductiveConstructor{swap}\AgdaSpace{}%
\AgdaBound{twiddleFactorsApplied}\AgdaSymbol{)}\<%
\\
%
\>[6]\AgdaKeyword{in}%
\>[10]\AgdaFunction{reshape}\AgdaSpace{}%
\AgdaInductiveConstructor{swap}\AgdaSpace{}%
\AgdaBound{outerDFTapplied}\<%
\end{code}
%TC:ignore
\begin{code}[hide]%
%
\>[6]\AgdaKeyword{where}\<%
\\
\>[6][@{}l@{\AgdaIndent{0}}]%
\>[8]\AgdaKeyword{postulate}\<%
\\
\>[8][@{}l@{\AgdaIndent{0}}]%
\>[10]\AgdaKeyword{instance}\<%
\\
\>[10][@{}l@{\AgdaIndent{0}}]%
\>[12]\AgdaPostulate{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NonZeroₛ}\AgdaSpace{}%
\AgdaBound{r₁}\<%
\\
%
\>[12]\AgdaPostulate{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NonZeroₛ}\AgdaSpace{}%
\AgdaBound{r₂}\<%
\\
%
\>[12]\AgdaPostulate{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NonZeroₛ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{r₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⊗}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{r₁}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{ᵗ}}\AgdaSymbol{))}\<%
\end{code}
%TC:endignore
\end{AgdaSuppressSpace}

As time was invested at the start of the project into a the creation of a language 
on tensors and reshaping, every case of the Cooley Tukey algorithm can be 
represented within the three lines shown above. 
Given a proof of correctness, this generality makes way for further experiments 
into different radix sizes, and combination of radix sizes, to be easily undertaken.

If this was instead written in \verb|C|, or a \verb|C| style language, this level
of generality would be almost impossible.
Any such general, \verb|C| style implementation would require many, low level,
index manipulations.
Without structures such as those defined for here for position, these index manipulations 
become increasingly complex as the radix sizes, and levels of nesting, increase.
This complexity makes it difficult to reason upon any such implementation meaning
garuntees are more challenging to achive.


% Spend some time explaining why expressing the FFT in the way we did is very good - Its a family of cooley tukey algorithms in 3 lines
% - The reason we can do this because we have invsted in these arrays and combinators on them
% - Doing this in C would be hell - we need to spoon feed this to the reader, this FFT definition is very cool!




